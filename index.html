<!doctype html>

<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Stencil A4 Maker</title>
  <style>
    * { box-sizing: border-box; }
    body { font-family: -apple-system, system-ui, sans-serif; padding: 16px; max-width: 800px; margin: 0 auto; background: #f5f5f5; }
    h3 { margin: 0 0 14px 0; font-size: 18px; }
    #dropZone {
      border: 3px dashed #aaa; border-radius: 14px; background: #fff;
      text-align: center; padding: 36px 20px; cursor: pointer;
      transition: border-color 0.2s, background 0.2s; margin-bottom: 16px;
    }
    #dropZone.over     { border-color: #0071e3; background: #e8f0ff; }
    #dropZone.has-file { border-color: #34c759; background: #f0fff4; }
    #dropZone .icon      { font-size: 48px; line-height: 1; margin-bottom: 8px; }
    #dropZone .main-text { font-size: 17px; font-weight: bold; color: #333; }
    #dropZone .sub-text  { font-size: 13px; color: #888; margin-top: 4px; }
    #fileInput { display: none; }
    .controls {
      display: flex; align-items: center; gap: 12px;
      background: #fff; border-radius: 12px; padding: 14px 16px;
      margin-bottom: 16px; flex-wrap: wrap;
    }
    .controls label { font-size: 15px; font-weight: bold; white-space: nowrap; }
    .controls input[type="number"] {
      width: 90px; padding: 10px; font-size: 20px; font-weight: bold;
      border: 2px solid #ccc; border-radius: 8px; text-align: center;
    }
    .controls input[type="number"]:focus { border-color: #0071e3; outline: none; }
    .controls .unit       { font-size: 16px; color: #555; }
    .controls .hint-small { font-size: 12px; color: #999; }
    .status { font-size: 13px; color: #555; margin-bottom: 8px; min-height: 18px; }
    .error  { color: #c00; }
    #dlBtn {
      display: none; margin-bottom: 12px;
      padding: 12px 24px; font-size: 15px;
      background: #34c759; color: #fff;
      border: none; border-radius: 10px; cursor: pointer; text-decoration: none;
    }
    #outImg { width: 100%; height: auto; border-radius: 8px; border: 1px solid #ddd; display: none; }
  </style>
</head>
<body>
  <h3>Stencil A4 Maker</h3>

  <div id="dropZone">
    <div class="icon">ğŸ–¼ï¸</div>
    <div class="main-text">ç”»åƒã‚’ã‚¿ãƒƒãƒ—ã—ã¦é¸æŠ</div>
    <div class="sub-text">ã¾ãŸã¯ã“ã“ã«ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—</div>
  </div>
  <input id="fileInput" type="file" accept="image/*" />

  <div class="controls">
    <label for="baseCm">åŸºæº–ã‚µã‚¤ã‚ºï¼ˆé•·è¾ºï¼‰</label>
    <input id="baseCm" type="number" inputmode="decimal" min="0.1" max="25" step="0.1" value="7" />
    <span class="unit">cm</span>
    <span class="hint-small">å¤‰æ›´ã™ã‚‹ã¨è‡ªå‹•ã§å†ç”Ÿæˆã—ã¾ã™</span>
  </div>

  <p class="status" id="status">ç”»åƒã‚’é¸æŠã™ã‚‹ã¨è‡ªå‹•ã§ç”Ÿæˆã—ã¾ã™</p>
  <a id="dlBtn" download="stencil_a4.png">ğŸ’¾ PNG ã‚’ä¿å­˜</a>
  <img id="outImg" alt="output" />

  <script>
    'use strict';

    const DPI    = 300;
    const $id    = (id) => document.getElementById(id);

    const dropZone  = $id('dropZone');
    const fileInput = $id('fileInput');

    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover',  (e) => { e.preventDefault(); dropZone.classList.add('over'); });
    dropZone.addEventListener('dragleave', ()  => dropZone.classList.remove('over'));
    dropZone.addEventListener('drop', (e) => {
      e.preventDefault(); dropZone.classList.remove('over');
      const f = e.dataTransfer.files[0];
      if (f && f.type.startsWith('image/')) handleFile(f);
    });
    fileInput.addEventListener('change', () => { const f = fileInput.files[0]; if (f) handleFile(f); });
    $id('baseCm').addEventListener('input', () => { if (currentDataURL) scheduleGenerate(); });

    let currentDataURL = null;
    let generateTimer  = null;

    function handleFile(file) {
      dropZone.classList.add('has-file');
      dropZone.querySelector('.main-text').textContent = file.name;
      dropZone.querySelector('.sub-text').textContent  = 'åˆ¥ã®ç”»åƒã‚’é¸ã¶ã«ã¯ã‚¿ãƒƒãƒ—';
      showStatus('èª­ã¿è¾¼ã¿ä¸­â€¦');
      const reader = new FileReader();
      reader.onload  = (e) => { currentDataURL = e.target.result; scheduleGenerate(); };
      reader.onerror = ()  => showStatus('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ', true);
      reader.readAsDataURL(file);
    }

    function scheduleGenerate() {
      clearTimeout(generateTimer);
      generateTimer = setTimeout(generate, 300);
    }

    function showStatus(msg, isError = false) {
      const el = $id('status');
      el.textContent = msg;
      el.className = 'status' + (isError ? ' error' : '');
    }

    function cmToPx(cm) { return (cm / 2.54) * DPI; }

    const PAGE_W = Math.round(cmToPx(21.0));
    const PAGE_H = Math.round(cmToPx(29.7));

    function loadImage(dataURL) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload  = () => resolve(img);
        img.onerror = () => reject(new Error('ç”»åƒã®ãƒ‡ã‚³ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ'));
        img.src = dataURL;
      });
    }

    function drawImageTransformed(ctx, img, x, y, w, h, rotate) {
      ctx.save();
      ctx.translate(x + w / 2, y + h / 2);
      if (rotate) ctx.rotate(Math.PI / 2);
      ctx.scale(-1, 1);
      const dw = rotate ? h : w;
      const dh = rotate ? w : h;
      ctx.drawImage(img, -dw / 2, -dh / 2, dw, dh);
      ctx.restore();
    }

    /**
     * ãƒ«ãƒ¼ãƒ©ãƒ¼ã‚’æç”»ã™ã‚‹
     * rulerW : ãƒ«ãƒ¼ãƒ©ãƒ¼å¸¯ã®å¹…(px)  â† å·¦ãƒ«ãƒ¼ãƒ©ãƒ¼ç”¨
     * rulerH : ãƒ«ãƒ¼ãƒ©ãƒ¼å¸¯ã®é«˜ã•(px) â† ä¸Šãƒ«ãƒ¼ãƒ©ãƒ¼ç”¨
     * originX, originY : ã‚³ãƒ³ãƒ†ãƒ³ãƒ„é ˜åŸŸã®å·¦ä¸Šï¼ˆãƒ«ãƒ¼ãƒ©ãƒ¼ã®0ã®ä½ç½®ï¼‰
     */
    function drawRulers(ctx, originX, originY, contentW, contentH, rulerSize) {
      const oneCm     = cmToPx(1);
      const halfCm    = cmToPx(0.5);
      const tickLong  = rulerSize * 0.55;  // 1cmç›®ç››ã‚Šã®é•·ã•
      const tickShort = rulerSize * 0.30;  // 5mmç›®ç››ã‚Šã®é•·ã•
      const fontSize  = Math.max(10, Math.round(rulerSize * 0.38));

      ctx.save();
      ctx.strokeStyle = '#444';
      ctx.fillStyle   = '#444';
      ctx.lineWidth   = Math.max(1, Math.round(cmToPx(0.02)));
      ctx.font        = `${fontSize}px sans-serif`;

      // ===== ä¸Šéƒ¨ãƒ«ãƒ¼ãƒ©ãƒ¼ï¼ˆæ¨ªæ–¹å‘ï¼‰=====
      // èƒŒæ™¯
      ctx.fillStyle = '#f0f0f0';
      ctx.fillRect(originX, 0, contentW, rulerSize);
      ctx.fillStyle = '#444';

      // ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ï¼ˆãƒ«ãƒ¼ãƒ©ãƒ¼ä¸‹ç«¯ï¼‰
      ctx.beginPath();
      ctx.moveTo(originX, rulerSize);
      ctx.lineTo(originX + contentW, rulerSize);
      ctx.stroke();

      // ç›®ç››ã‚Šï¼š0ã‹ã‚‰21cmã¾ã§ï¼ˆã‚³ãƒ³ãƒ†ãƒ³ãƒ„å¹…å†…ï¼‰
      const hMaxCm = Math.ceil(contentW / oneCm) + 1;
      for (let i = 0; i * oneCm <= contentW + 1; i++) {
        const x = originX + i * oneCm;
        if (x > originX + contentW + 1) break;

        // 1cmç›®ç››ã‚Šï¼ˆé•·ã„ï¼‰
        ctx.beginPath();
        ctx.moveTo(x, rulerSize);
        ctx.lineTo(x, rulerSize - tickLong);
        ctx.stroke();

        // æ•°å­—ãƒ©ãƒ™ãƒ«ï¼ˆåè»¢ã—ã¦è¡¨ç¤ºï¼‰
        if (i > 0) {
          ctx.save();
          ctx.translate(x, rulerSize - tickLong - fontSize * 0.1);
          ctx.scale(-1, 1); // å·¦å³åè»¢
          ctx.textAlign    = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText(String(i), 0, 0);
          ctx.restore();
        }

        // 5mmç›®ç››ã‚Šï¼ˆçŸ­ã„ï¼‰
        const x5 = x + halfCm;
        if (x5 <= originX + contentW) {
          ctx.beginPath();
          ctx.moveTo(x5, rulerSize);
          ctx.lineTo(x5, rulerSize - tickShort);
          ctx.stroke();
        }
      }

      // ===== å·¦å´ãƒ«ãƒ¼ãƒ©ãƒ¼ï¼ˆç¸¦æ–¹å‘ï¼‰=====
      // èƒŒæ™¯
      ctx.fillStyle = '#f0f0f0';
      ctx.fillRect(0, originY, rulerSize, contentH);
      ctx.fillStyle = '#444';

      // ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ï¼ˆãƒ«ãƒ¼ãƒ©ãƒ¼å³ç«¯ï¼‰
      ctx.beginPath();
      ctx.moveTo(rulerSize, originY);
      ctx.lineTo(rulerSize, originY + contentH);
      ctx.stroke();

      // ç›®ç››ã‚Š
      for (let i = 0; i * oneCm <= contentH + 1; i++) {
        const y = originY + i * oneCm;
        if (y > originY + contentH + 1) break;

        // 1cmç›®ç››ã‚Šï¼ˆé•·ã„ï¼‰
        ctx.beginPath();
        ctx.moveTo(rulerSize, y);
        ctx.lineTo(rulerSize - tickLong, y);
        ctx.stroke();

        // æ•°å­—ãƒ©ãƒ™ãƒ«ï¼ˆç¸¦æ›¸ãé¢¨ã«90åº¦å›è»¢ï¼‰
        if (i > 0) {
          ctx.save();
          ctx.translate(rulerSize - tickLong - fontSize * 0.15, y);
          ctx.rotate(-Math.PI / 2);
          ctx.textAlign    = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText(String(i), 0, 0);
          ctx.restore();
        }

        // 5mmç›®ç››ã‚Šï¼ˆçŸ­ã„ï¼‰
        const y5 = y + halfCm;
        if (y5 <= originY + contentH) {
          ctx.beginPath();
          ctx.moveTo(rulerSize, y5);
          ctx.lineTo(rulerSize - tickShort, y5);
          ctx.stroke();
        }
      }

      // å·¦ä¸Šã‚³ãƒ¼ãƒŠãƒ¼ï¼ˆäº¤å·®éƒ¨ã‚’å¡—ã‚Šã¤ã¶ã—ï¼‰
      ctx.fillStyle = '#e0e0e0';
      ctx.fillRect(0, 0, rulerSize, rulerSize);

      ctx.restore();
    }

    async function generate() {
      if (!currentDataURL) return;

      const baseCm = parseFloat($id('baseCm').value);
      if (!Number.isFinite(baseCm) || baseCm <= 0) {
        showStatus('åŸºæº–ã‚µã‚¤ã‚ºã«æ­£ã®æ•°å€¤ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', true);
        return;
      }

      showStatus('ç”Ÿæˆä¸­â€¦');

      try {
        const img = await loadImage(currentDataURL);
        const iw  = img.naturalWidth;
        const ih  = img.naturalHeight;
        if (iw === 0 || ih === 0) throw new Error('ç”»åƒã‚µã‚¤ã‚ºãŒä¸æ­£ã§ã™');

        const rotate   = iw > ih;
        const effW     = rotate ? ih : iw;
        const effH     = rotate ? iw : ih;
        const longEdge = effH;

        const canvas  = document.createElement('canvas');
        canvas.width  = PAGE_W;
        canvas.height = PAGE_H;
        const ctx = canvas.getContext('2d', { alpha: false });

        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, PAGE_W, PAGE_H);
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';

        // ãƒ«ãƒ¼ãƒ©ãƒ¼ã‚µã‚¤ã‚º = margin ã¨åŒã˜ 10mm
        const rulerSize = Math.round(cmToPx(1.0));
        const gap       = Math.round(cmToPx(0.5));

        // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„é ˜åŸŸï¼ˆãƒ«ãƒ¼ãƒ©ãƒ¼ã®å³ãƒ»ä¸‹ã‹ã‚‰å§‹ã¾ã‚‹ï¼‰
        const originX  = rulerSize;
        const originY  = rulerSize;
        const contentW = PAGE_W - rulerSize * 2; // å³ç«¯ã«ã‚‚å°‘ã—ä½™ç™½
        const contentH = PAGE_H - rulerSize * 2;

        // ãƒ«ãƒ¼ãƒ©ãƒ¼æç”»ï¼ˆç”»åƒã‚ˆã‚Šå…ˆã«æã„ã¦ä¸‹ã«æ•·ãï¼‰
        drawRulers(ctx, originX, originY, contentW, contentH, rulerSize);

        function drawSize(cm) {
          const scale = cmToPx(cm) / longEdge;
          return { w: effW * scale, h: effH * scale };
        }

        function tryLayout(nCols, sizes) {
          const cellW = Math.floor((contentW - gap * (nCols - 1)) / nCols);
          for (const cm of sizes) {
            const ds = drawSize(cm);
            if (ds.w > cellW + 0.5 || ds.h > contentH + 0.5) return null;
          }
          const cellH = Math.floor((contentH - gap) / 2);
          return { cellW, cellH };
        }

        function makeCandidates(step, count) {
          const half = Math.floor(count / 2);
          return Array.from({ length: count }, (_, i) => {
            const offset = (i - half) * step;
            return Math.max(0.1, Math.round((baseCm + offset) * 100) / 100);
          });
        }

        const trySets = [
          [5, 0.5], [4, 0.5],
          [5, 1.0], [4, 1.0], [3, 1.0], [2, 1.0], [1, 1.0],
        ];

        let bestLayout = null, bestCms = null, bestStep = 1.0, bestCount = 1;

        for (const [count, step] of trySets) {
          const cms    = makeCandidates(step, count);
          const layout = tryLayout(count, cms);
          if (layout) {
            bestLayout = layout; bestCms = cms; bestStep = step; bestCount = count;
            break;
          }
        }

        if (!bestLayout) {
          bestLayout = { cellW: contentW, cellH: Math.floor((contentH - gap) / 2) };
          bestCms = [baseCm]; bestCount = 1; bestStep = 1.0;
        }

        const { cellW, cellH } = bestLayout;
        const nCols = bestCount;

        const totalUsedW = nCols * cellW + (nCols - 1) * gap;
        const offsetX    = originX + Math.floor((contentW - totalUsedW) / 2);

        let someSingle = false;

        for (let col = 0; col < nCols; col++) {
          const cm    = bestCms[col];
          const ds    = drawSize(cm);
          const cellX = offsetX + col * (cellW + gap);

          const fitsDouble = (ds.h * 2 + gap) <= contentH + 0.5;
          const nRows = fitsDouble ? 2 : 1;
          if (nRows === 1) someSingle = true;

          for (let row = 0; row < nRows; row++) {
            let dy;
            if (nRows === 1) {
              dy = originY + (contentH - ds.h) / 2;
            } else {
              const cellY = originY + row * (cellH + gap);
              dy = cellY + (cellH - ds.h) / 2;
            }
            const dx = cellX + (cellW - ds.w) / 2;
            drawImageTransformed(ctx, img, dx, dy, ds.w, ds.h, rotate);
          }
        }

        // åŸºæº–ã‚µã‚¤ã‚ºæ³¨è¨˜ï¼ˆå³ä¸‹ãƒ»åè»¢ï¼‰
        const noteFontSize = Math.max(10, Math.round(cmToPx(0.28)));
        const noteText     = `åŸºæº– ${baseCm.toFixed(1)}cm`;
        const noteX = PAGE_W - rulerSize / 2;
        const noteY = PAGE_H - rulerSize / 3;

        ctx.save();
        ctx.font         = `${noteFontSize}px sans-serif`;
        ctx.textBaseline = 'bottom';
        ctx.fillStyle    = '#888';
        ctx.translate(noteX, noteY);
        ctx.scale(-1, 1);
        ctx.textAlign = 'left';
        ctx.fillText(noteText, 0, 0);
        ctx.restore();

        const dataUrl = canvas.toDataURL('image/png');
        $id('outImg').src = dataUrl;
        $id('outImg').style.display = 'block';
        $id('dlBtn').href = dataUrl;
        $id('dlBtn').style.display = 'inline-block';

        const stepLabel  = bestStep === 0.5 ? '0.5cmåˆ»ã¿' : '1cmåˆ»ã¿';
        const rotNote    = rotate     ? ' ï¼ 90Â°å›è»¢' : '';
        const singleNote = someSingle ? ' ï¼ ä¸€éƒ¨1æš' : '';
        showStatus(`å®Œäº† â€” ${nCols}ç¨®é¡ ${stepLabel}${rotNote}${singleNote}ã€€` +
          bestCms.map(c => c.toFixed(1) + 'cm').join(' / '));

      } catch (err) {
        console.error(err);
        showStatus('ã‚¨ãƒ©ãƒ¼ï¼š' + (err.message || 'ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ'), true);
      }
    }
  </script>

</body>
</html>
