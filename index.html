<!doctype html>

<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Stencil A4 Maker</title>
  <style>
    * { box-sizing: border-box; }
    body { font-family: -apple-system, system-ui, sans-serif; padding: 16px; max-width: 800px; margin: 0 auto; background: #f5f5f5; }
    h3 { margin: 0 0 14px 0; font-size: 18px; }
    #dropZone {
      border: 3px dashed #aaa; border-radius: 14px; background: #fff;
      text-align: center; padding: 36px 20px; cursor: pointer;
      transition: border-color 0.2s, background 0.2s; margin-bottom: 16px;
    }
    #dropZone.over     { border-color: #0071e3; background: #e8f0ff; }
    #dropZone.has-file { border-color: #34c759; background: #f0fff4; }
    #dropZone .icon      { font-size: 48px; line-height: 1; margin-bottom: 8px; }
    #dropZone .main-text { font-size: 17px; font-weight: bold; color: #333; }
    #dropZone .sub-text  { font-size: 13px; color: #888; margin-top: 4px; }
    #fileInput { display: none; }

```
.controls {
  display: flex; align-items: center; gap: 12px;
  background: #fff; border-radius: 12px; padding: 14px 16px;
  margin-bottom: 12px; flex-wrap: wrap;
}
.controls label { font-size: 15px; font-weight: bold; white-space: nowrap; }
.controls input[type="number"] {
  width: 90px; padding: 10px; font-size: 20px; font-weight: bold;
  border: 2px solid #ccc; border-radius: 8px; text-align: center;
}
.controls input[type="number"]:focus { border-color: #0071e3; outline: none; }
.controls .unit       { font-size: 16px; color: #555; }
.controls .hint-small { font-size: 12px; color: #999; }

/* å‘ããƒˆã‚°ãƒ«ãƒœã‚¿ãƒ³ */
#orientBtn {
  display: flex; align-items: center; gap: 8px;
  background: #fff; border-radius: 12px; padding: 12px 16px;
  margin-bottom: 12px; border: 2px solid #ddd; cursor: pointer;
  font-size: 15px; font-weight: bold; color: #333;
  transition: border-color 0.2s, background 0.2s;
  width: 100%;
}
#orientBtn:hover { border-color: #0071e3; }
#orientBtn .icon-wrap {
  font-size: 28px; line-height: 1;
  transition: transform 0.3s ease;
}
#orientBtn.landscape .icon-wrap { transform: rotate(90deg); }
#orientBtn .label-main { font-size: 15px; font-weight: bold; }
#orientBtn .label-sub  { font-size: 12px; color: #888; margin-left: 4px; }

.status { font-size: 13px; color: #555; margin-bottom: 8px; min-height: 18px; }
.error  { color: #c00; }
#dlBtn {
  display: none; margin-bottom: 12px;
  padding: 12px 24px; font-size: 15px;
  background: #34c759; color: #fff;
  border: none; border-radius: 10px; cursor: pointer; text-decoration: none;
}
#outImg { width: 100%; height: auto; border-radius: 8px; border: 1px solid #ddd; display: none; }
```

  </style>
</head>
<body>
  <h3>Stencil A4 Maker</h3>

  <div id="dropZone">
    <div class="icon">ğŸ–¼ï¸</div>
    <div class="main-text">ç”»åƒã‚’ã‚¿ãƒƒãƒ—ã—ã¦é¸æŠ</div>
    <div class="sub-text">ã¾ãŸã¯ã“ã“ã«ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—</div>
  </div>
  <input id="fileInput" type="file" accept="image/*" />

  <div class="controls">
    <label for="baseCm">åŸºæº–ã‚µã‚¤ã‚ºï¼ˆé•·è¾ºï¼‰</label>
    <input id="baseCm" type="number" inputmode="decimal" min="0.1" max="25" step="0.1" value="7" />
    <span class="unit">cm</span>
    <span class="hint-small">å¤‰æ›´ã™ã‚‹ã¨è‡ªå‹•ã§å†ç”Ÿæˆã—ã¾ã™</span>
  </div>

  <!-- å‘ãåˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ -->

  <button id="orientBtn">
    <span class="icon-wrap">ğŸ“±</span>
    <span class="label-main" id="orientLabel">é•·è¾ºï¼šç¸¦</span>
    <span class="label-sub">ã‚¿ãƒƒãƒ—ã§æ¨ªã«åˆ‡ã‚Šæ›¿ãˆ</span>
  </button>

  <p class="status" id="status">ç”»åƒã‚’é¸æŠã™ã‚‹ã¨è‡ªå‹•ã§ç”Ÿæˆã—ã¾ã™</p>
  <a id="dlBtn" download="stencil_a4.png">ğŸ’¾ PNG ã‚’ä¿å­˜</a>
  <img id="outImg" alt="output" />

  <script>
    'use strict';

    const DPI = 300;
    const $id = (id) => document.getElementById(id);

    // --- å‘ãçŠ¶æ…‹ ---
    // forceRotate: null=è‡ªå‹•ï¼ˆæ¨ªé•·ç”»åƒã ã‘å›è»¢ï¼‰, 'portrait'=å¼·åˆ¶ç¸¦, 'landscape'=å¼·åˆ¶æ¨ª
    // ãƒœã‚¿ãƒ³ã§åˆ‡ã‚Šæ›¿ãˆã‚‹ã®ã¯ã€Œé•·è¾ºã‚’ç¸¦ or æ¨ªã€
    // true = é•·è¾ºã‚’ç¸¦ã«ã™ã‚‹ï¼ˆ= æ¨ªé•·ç”»åƒã‚’90åº¦å›è»¢ã—ã¦ç¸¦ã«ã™ã‚‹ã€ç¸¦é•·ã¯ãã®ã¾ã¾ï¼‰
    // false = é•·è¾ºã‚’æ¨ªã«ã™ã‚‹ï¼ˆ= ç¸¦é•·ç”»åƒã‚’90åº¦å›è»¢ã—ã¦æ¨ªã«ã™ã‚‹ã€æ¨ªé•·ã¯ãã®ã¾ã¾ï¼‰
    let longSideVertical = true; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼šé•·è¾ºç¸¦

    const orientBtn   = $id('orientBtn');
    const orientLabel = $id('orientLabel');

    orientBtn.addEventListener('click', () => {
      longSideVertical = !longSideVertical;
      updateOrientBtn();
      if (currentDataURL) scheduleGenerate();
    });

    function updateOrientBtn() {
      if (longSideVertical) {
        orientBtn.classList.remove('landscape');
        orientLabel.textContent = 'é•·è¾ºï¼šç¸¦';
        orientBtn.querySelector('.label-sub').textContent = 'ã‚¿ãƒƒãƒ—ã§æ¨ªã«åˆ‡ã‚Šæ›¿ãˆ';
      } else {
        orientBtn.classList.add('landscape');
        orientLabel.textContent = 'é•·è¾ºï¼šæ¨ª';
        orientBtn.querySelector('.label-sub').textContent = 'ã‚¿ãƒƒãƒ—ã§ç¸¦ã«åˆ‡ã‚Šæ›¿ãˆ';
      }
    }

    // --- ãƒ‰ãƒ­ãƒƒãƒ—ã‚¾ãƒ¼ãƒ³ ---
    const dropZone  = $id('dropZone');
    const fileInput = $id('fileInput');

    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover',  (e) => { e.preventDefault(); dropZone.classList.add('over'); });
    dropZone.addEventListener('dragleave', ()  => dropZone.classList.remove('over'));
    dropZone.addEventListener('drop', (e) => {
      e.preventDefault(); dropZone.classList.remove('over');
      const f = e.dataTransfer.files[0];
      if (f && f.type.startsWith('image/')) handleFile(f);
    });
    fileInput.addEventListener('change', () => { const f = fileInput.files[0]; if (f) handleFile(f); });
    $id('baseCm').addEventListener('input', () => { if (currentDataURL) scheduleGenerate(); });

    let currentDataURL = null;
    let generateTimer  = null;

    function handleFile(file) {
      dropZone.classList.add('has-file');
      dropZone.querySelector('.main-text').textContent = file.name;
      dropZone.querySelector('.sub-text').textContent  = 'åˆ¥ã®ç”»åƒã‚’é¸ã¶ã«ã¯ã‚¿ãƒƒãƒ—';
      showStatus('èª­ã¿è¾¼ã¿ä¸­â€¦');
      const reader = new FileReader();
      reader.onload  = (e) => { currentDataURL = e.target.result; scheduleGenerate(); };
      reader.onerror = ()  => showStatus('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ', true);
      reader.readAsDataURL(file);
    }

    function scheduleGenerate() {
      clearTimeout(generateTimer);
      generateTimer = setTimeout(generate, 300);
    }

    function showStatus(msg, isError = false) {
      const el = $id('status');
      el.textContent = msg;
      el.className = 'status' + (isError ? ' error' : '');
    }

    function cmToPx(cm) { return (cm / 2.54) * DPI; }

    const PAGE_W = Math.round(cmToPx(21.0));
    const PAGE_H = Math.round(cmToPx(29.7));

    function loadImage(dataURL) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload  = () => resolve(img);
        img.onerror = () => reject(new Error('ç”»åƒã®ãƒ‡ã‚³ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ'));
        img.src = dataURL;
      });
    }

    // rotate: true = 90åº¦å›è»¢ã—ã¦æç”»
    function drawImageTransformed(ctx, img, x, y, w, h, rotate) {
      ctx.save();
      ctx.translate(x + w / 2, y + h / 2);
      if (rotate) ctx.rotate(Math.PI / 2);
      ctx.scale(-1, 1); // å·¦å³åè»¢å›ºå®š
      const dw = rotate ? h : w;
      const dh = rotate ? w : h;
      ctx.drawImage(img, -dw / 2, -dh / 2, dw, dh);
      ctx.restore();
    }

    function drawRulers(ctx, originX, originY, contentW, contentH, rulerSize) {
      const oneCm     = cmToPx(1);
      const halfCm    = cmToPx(0.5);
      const tickLong  = rulerSize * 0.55;
      const tickShort = rulerSize * 0.30;
      const fontSize  = Math.max(10, Math.round(rulerSize * 0.38));

      ctx.save();
      ctx.lineWidth = Math.max(1, Math.round(cmToPx(0.02)));
      ctx.font      = `${fontSize}px sans-serif`;

      // ä¸Šéƒ¨ãƒ«ãƒ¼ãƒ©ãƒ¼
      ctx.fillStyle = '#f0f0f0';
      ctx.fillRect(originX, 0, contentW, rulerSize);
      ctx.strokeStyle = '#444'; ctx.fillStyle = '#444';
      ctx.beginPath(); ctx.moveTo(originX, rulerSize); ctx.lineTo(originX + contentW, rulerSize); ctx.stroke();

      for (let i = 0; i * oneCm <= contentW + 1; i++) {
        const x = originX + i * oneCm;
        if (x > originX + contentW + 1) break;
        ctx.beginPath(); ctx.moveTo(x, rulerSize); ctx.lineTo(x, rulerSize - tickLong); ctx.stroke();
        if (i > 0) {
          ctx.save();
          ctx.translate(x, rulerSize - tickLong - fontSize * 0.1);
          ctx.scale(-1, 1);
          ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
          ctx.fillText(String(i), 0, 0);
          ctx.restore();
        }
        const x5 = x + halfCm;
        if (x5 <= originX + contentW) {
          ctx.beginPath(); ctx.moveTo(x5, rulerSize); ctx.lineTo(x5, rulerSize - tickShort); ctx.stroke();
        }
      }

      // å·¦å´ãƒ«ãƒ¼ãƒ©ãƒ¼
      ctx.fillStyle = '#f0f0f0';
      ctx.fillRect(0, originY, rulerSize, contentH);
      ctx.strokeStyle = '#444'; ctx.fillStyle = '#444';
      ctx.beginPath(); ctx.moveTo(rulerSize, originY); ctx.lineTo(rulerSize, originY + contentH); ctx.stroke();

      for (let i = 0; i * oneCm <= contentH + 1; i++) {
        const y = originY + i * oneCm;
        if (y > originY + contentH + 1) break;
        ctx.beginPath(); ctx.moveTo(rulerSize, y); ctx.lineTo(rulerSize - tickLong, y); ctx.stroke();
        if (i > 0) {
          ctx.save();
          ctx.translate(rulerSize - tickLong - fontSize * 0.15, y);
          ctx.rotate(-Math.PI / 2);
          ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
          ctx.fillText(String(i), 0, 0);
          ctx.restore();
        }
        const y5 = y + halfCm;
        if (y5 <= originY + contentH) {
          ctx.beginPath(); ctx.moveTo(rulerSize, y5); ctx.lineTo(rulerSize - tickShort, y5); ctx.stroke();
        }
      }

      // å·¦ä¸Šã‚³ãƒ¼ãƒŠãƒ¼
      ctx.fillStyle = '#e0e0e0';
      ctx.fillRect(0, 0, rulerSize, rulerSize);
      ctx.restore();
    }

    async function generate() {
      if (!currentDataURL) return;

      const baseCm = parseFloat($id('baseCm').value);
      if (!Number.isFinite(baseCm) || baseCm <= 0) {
        showStatus('åŸºæº–ã‚µã‚¤ã‚ºã«æ­£ã®æ•°å€¤ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', true);
        return;
      }

      showStatus('ç”Ÿæˆä¸­â€¦');

      try {
        const img = await loadImage(currentDataURL);
        const iw  = img.naturalWidth;
        const ih  = img.naturalHeight;
        if (iw === 0 || ih === 0) throw new Error('ç”»åƒã‚µã‚¤ã‚ºãŒä¸æ­£ã§ã™');

        // --- å‘ãè¨ˆç®— ---
        // longSideVertical=true  â†’ é•·è¾ºãŒç¸¦ã«ãªã‚‹ã‚ˆã†é…ç½®
        //   ç¸¦é•·(ih>=iw): ãã®ã¾ã¾(rotate=false)
        //   æ¨ªé•·(iw>ih) : 90åº¦å›è»¢(rotate=true)
        // longSideVertical=false â†’ é•·è¾ºãŒæ¨ªã«ãªã‚‹ã‚ˆã†é…ç½®
        //   æ¨ªé•·(iw>ih) : ãã®ã¾ã¾(rotate=false)
        //   ç¸¦é•·(ih>=iw): 90åº¦å›è»¢(rotate=true)
        const isPortrait = ih >= iw; // å…ƒç”»åƒãŒç¸¦é•·ã‹
        let rotate;
        if (longSideVertical) {
          rotate = !isPortrait; // æ¨ªé•·ãªã‚‰å›è»¢ã—ã¦ç¸¦ã«
        } else {
          rotate = isPortrait;  // ç¸¦é•·ãªã‚‰å›è»¢ã—ã¦æ¨ªã«
        }

        // å›è»¢å¾Œã®å®ŸåŠ¹ã‚µã‚¤ã‚º
        const effW = rotate ? ih : iw;
        const effH = rotate ? iw : ih;
        // é•·è¾ºï¼ˆåŸºæº–ã«ã™ã‚‹è¾ºï¼‰
        const longEdge = Math.max(effW, effH);

        const canvas  = document.createElement('canvas');
        canvas.width  = PAGE_W;
        canvas.height = PAGE_H;
        const ctx = canvas.getContext('2d', { alpha: false });

        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, PAGE_W, PAGE_H);
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';

        const rulerSize = Math.round(cmToPx(1.0));
        const gap       = Math.round(cmToPx(0.5));
        const originX   = rulerSize;
        const originY   = rulerSize;
        const contentW  = PAGE_W - rulerSize * 2;
        const contentH  = PAGE_H - rulerSize * 2;

        drawRulers(ctx, originX, originY, contentW, contentH, rulerSize);

        function drawSize(cm) {
          const scale = cmToPx(cm) / longEdge;
          return { w: effW * scale, h: effH * scale };
        }

        // nRowsè¡Œãƒ»å„è¡Œ2æšæ¨ªä¸¦ã³ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã§å…¨ã‚µã‚¤ã‚ºãŒåã¾ã‚‹ã‹åˆ¤å®š
        function tryLayout(nRows, sizes) {
          const cellW = Math.floor((contentW - gap) / 2);
          const cellH = Math.floor((contentH - gap * (nRows - 1)) / nRows);
          if (cellH <= 0) return null;
          for (const cm of sizes) {
            const ds = drawSize(cm);
            if (ds.w > cellW + 0.5 || ds.h > cellH + 0.5) return null;
          }
          return { cellW, cellH };
        }

        function makeCandidates(step, count) {
          const half = Math.floor(count / 2);
          return Array.from({ length: count }, (_, i) => {
            const offset = (i - half) * step;
            return Math.max(0.1, Math.round((baseCm + offset) * 100) / 100);
          });
        }

        const trySets = [
          [5, 0.5], [4, 0.5],
          [5, 1.0], [4, 1.0], [3, 1.0], [2, 1.0], [1, 1.0],
        ];

        let bestLayout = null, bestCms = null, bestStep = 1.0, bestCount = 1;

        for (const [count, step] of trySets) {
          const cms    = makeCandidates(step, count);
          const layout = tryLayout(count, cms);
          if (layout) {
            bestLayout = layout; bestCms = cms; bestStep = step; bestCount = count;
            break;
          }
        }

        if (!bestLayout) {
          bestLayout = { cellW: contentW, cellH: contentH };
          bestCms = [baseCm]; bestCount = 1; bestStep = 1.0;
        }

        const { cellW, cellH } = bestLayout;
        const nRows = bestCount;

        // è¡Œã‚°ãƒ«ãƒ¼ãƒ—å…¨ä½“ã‚’å‚ç›´ä¸­å¤®æƒãˆ
        const totalUsedH = nRows * cellH + (nRows - 1) * gap;
        const offsetY    = originY + Math.floor((contentH - totalUsedH) / 2);

        let someSingle = false;

        for (let row = 0; row < nRows; row++) {
          const cm   = bestCms[row];
          const ds   = drawSize(cm);
          const rowY = offsetY + row * (cellH + gap);

          // æ¨ª2æšãŒåã¾ã‚‹ã‹
          const fitsDouble = (ds.w * 2 + gap) <= contentW + 0.5;
          const nCols = fitsDouble ? 2 : 1;
          if (nCols === 1) someSingle = true;

          const totalImgW = nCols === 2 ? ds.w * 2 + gap : ds.w;
          const startX    = originX + Math.floor((contentW - totalImgW) / 2);

          for (let col = 0; col < nCols; col++) {
            const dx = startX + col * (ds.w + gap);
            const dy = rowY + (cellH - ds.h) / 2;
            drawImageTransformed(ctx, img, dx, dy, ds.w, ds.h, rotate);
          }
        }

        // åŸºæº–ã‚µã‚¤ã‚ºæ³¨è¨˜ï¼ˆå³ä¸‹ãƒ»åè»¢ï¼‰
        const noteFontSize = Math.max(10, Math.round(cmToPx(0.28)));
        const noteText     = `åŸºæº– ${baseCm.toFixed(1)}cm`;
        ctx.save();
        ctx.font = `${noteFontSize}px sans-serif`;
        ctx.textBaseline = 'bottom'; ctx.fillStyle = '#888';
        ctx.translate(PAGE_W - rulerSize / 2, PAGE_H - rulerSize / 3);
        ctx.scale(-1, 1); ctx.textAlign = 'left';
        ctx.fillText(noteText, 0, 0);
        ctx.restore();

        const dataUrl = canvas.toDataURL('image/png');
        $id('outImg').src = dataUrl;
        $id('outImg').style.display = 'block';
        $id('dlBtn').href = dataUrl;
        $id('dlBtn').style.display = 'inline-block';

        const stepLabel   = bestStep === 0.5 ? '0.5cmåˆ»ã¿' : '1cmåˆ»ã¿';
        const rotNote     = rotate     ? ' ï¼ 90Â°å›è»¢' : '';
        const singleNote  = someSingle ? ' ï¼ ä¸€éƒ¨1æš' : '';
        const orientNote  = longSideVertical ? 'é•·è¾ºç¸¦' : 'é•·è¾ºæ¨ª';
        showStatus(`å®Œäº† â€” ${nRows}ç¨®é¡ ${stepLabel} ${orientNote}${rotNote}${singleNote}ã€€` +
          bestCms.map(c => c.toFixed(1) + 'cm').join(' / '));

      } catch (err) {
        console.error(err);
        showStatus('ã‚¨ãƒ©ãƒ¼ï¼š' + (err.message || 'ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ'), true);
      }
    }
  </script>

</body>
</html>